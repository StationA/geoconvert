package vm

type XGeoCompiler Peg {
    constants     []Value
    code          []*Code
    jumpStack     []*Code
    registerCount int
    refs          map[string]int
}

file <- wsn section* !.

section <- comment / block / stmt

comment <- '//' (!'\n' .)* wsn

block <- if_else_block / if_block

if_block <- if_cond '{' wsn section* wsn '}' wsn {
    p.SetJump()
}

if_else_block <- if_cond '{' wsn section* wsn '}' wsn {
    p.SetJumpAfter()
    p.EmitJump()
} else_block wsn

if_cond <- 'if' ws '(' ws expr ws ')' wsn {
    p.EmitJumpIfFalse()
}

else_block <- 'else' wsn '{' wsn section* wsn '}' wsn {
    p.SetJump()
}

stmt <- (emit / assignment) wsn

emit <- 'emit' ws expr {
    p.EmitCode(OpEMIT)
}

assignment <- global_assignment / var_assignment

global_assignment <- <global_ref> {
    p.PrepareMutate(buffer[begin:end])
} ws '=' ws expr {
    p.EmitCode(OpMUT)
}

var_assignment <- <variable_ref> {
    p.AllocateRef(buffer[begin:end])
} ws '=' ws expr {
    p.EmitStore()
}

expr <- or_expr / primary

primary <- '(' ws expr ws ')' / func_call / literal / deref

or_expr <- and_expr (or_rhs+ { p.EmitJumpAfter(); p.EmitConstant(&Bool{true}) })?

or_rhs <- { p.EmitJumpIfTrue() } ws '||' ws and_expr { p.SetJumpAfter() }

and_expr <- compare_expr (and_rhs+ { p.EmitJumpAfter(); p.EmitConstant(&Bool{false}) })?

and_rhs <- { p.EmitJumpIfFalse() } ws '&&' ws compare_expr { p.SetJumpAfter() }

compare_expr <- add_expr (ws (
    '==' ws add_expr { p.EmitCode(OpEQ) }
  / '!=' ws add_expr { p.EmitCode(OpNEQ) }
  / '<' ws add_expr { p.EmitCode(OpLT) }
  / '<=' ws add_expr { p.EmitCode(OpLTE) }
  / '>' ws add_expr { p.EmitCode(OpGT) }
  / '>=' ws add_expr { p.EmitCode(OpGTE) }
))?

add_expr <- mult_expr (ws (
    '+' ws mult_expr { p.EmitCode(OpADD) }
  / '-' ws mult_expr { p.EmitCode(OpSUB) }
))*

mult_expr <- primary (ws (
    '*' ws primary { p.EmitCode(OpMUL) }
  / '/' ws primary { p.EmitCode(OpDIV) }
))*

func_call <- deref '(' wsn (expr (wsn ',' wsn expr)*)? wsn ')' {
    p.EmitCode(OpCALL)
}

ref <- global_ref / variable_ref

deref <- <ref> {
    p.EmitLoad(buffer[begin:end])
}

global_ref <- '@' (ident ('.' ident)*)?

variable_ref <- ident

ident <- [A-Za-z_][A-Za-z0-9_]*

literal <- bool / float / int / string

float <- <'-'? [0-9]+ '.' [0-9]*> {
    p.EmitConstant(ParseFloat(buffer[begin:end]))
}

int <- <'-'? [0-9]+> {
    p.EmitConstant(ParseInt(buffer[begin:end]))
}

bool <- <'true' / 'false'> {
    p.EmitConstant(ParseBool(buffer[begin:end]))
}

string <- '"' <[^"]*> '"' {
    p.EmitConstant(&Str{buffer[begin:end]})
}

ws <- (' ' / '\t')*

wsn <- (' ' / '\t' / '\n')*
